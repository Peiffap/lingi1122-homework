\documentclass{elsarticle}
\usepackage[a4paper,left=2.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm]{geometry}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathtools}
\usepackage[french]{babel}
\usepackage{bm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{dafny}
\lstset{language=dafny}
\graphicspath{{img/}}
\usepackage{svg}

\makeatletter
\def\ps@pprintTitle{%
	\let\@oddhead\@empty
	\let\@evenhead\@empty
	\def\@oddfoot{\centerline{\thepage}}%
	\let\@evenfoot\@oddfoot}
\makeatother

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
		T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\abs}[1]{\left\lvert#1\right\lvert}
\usepackage{siunitx}
\begin{document}
\title{Méthodes de conception de programmes \\ Devoir 1: Preuve de programme}
\date{12 mars 2019}

\address[add1]{École Polytechnique, Université catholique de Louvain, Place de l'Université 1, 1348 Ottignies-Louvain-la-Neuve, Belgique}

\author[add1]{Alexandre \textsc{Gobeaux}}
\ead{alexandre.gobeaux@student.uclouvain.be}
\author[add1]{Louis \textsc{Navarre}}
\ead{louis.navarre@student.uclouvain.be}
\author[add1]{Gilles \textsc{Peiffer}}
\ead{gilles.peiffer@student.uclouvain.be}

\begin{abstract}
Ce document donne un algorithme pour résoudre le problème 2SUM ainsi qu'une preuve de correction totale pour celui-ci, par rapport aux spécifications définies.
\end{abstract}
\maketitle

\section{Description du problème et de la solution}
Le problème à résoudre est celui d'une séquence d'entiers triée $a$ dans laquelle il faut déterminer si oui ou non deux d'entre-eux (potentiellement deux fois le même) ont une somme égale à un entier prédéfini $s$.
Si oui, alors le programme doit renvoyer \og \inlinedafny{true} \fg, ainsi que les indices des deux entiers qui satisfont la condition, sinon il renvoie \og \inlinedafny{false} \fg, et la valeur des indices n'a pas d'importance.

Notre algorithme fonctionne en temps linéaire ($\mathcal{O}(n)$), en utilisant deux pointeurs:
le premier commence au premier élément du tableau, alors que le deuxième commence à la fin.
On évalue leur somme à chaque itération, tant que le premier pointeur est plus bas que le second:
\begin{itemize}
	\item si celle-ci est plus petite que $s$, on avance d'une unité le premier pointeur;
	\item si celle-ci est plus grande que $s$, on recule d'une unité le deuxième pointeur et
	\item si celle-ci est égale à $s$, on retourne les valeurs ainsi que la valeur \og \inlinedafny{true}\fg.
\end{itemize}
L'algorithme peut donc se terminer de deux façons: soit il trouve une paire d'indices qui satisfait la condition, passant donc dans la troisième possibilité ci-dessus,
soit les pointeurs se croisent, ce qui signifie que la séquence ne contient pas de paire satisfaisant la condition.

\section{Spécification formelle}
\subsection{Précondition}
La précondition est que la séquence soit triée.
Formellement, on demande que
\[
\forall k, \ell \mid 0 \le k \le \ell < \abs{a} :: a[k] \le a[l]\,.
\]
\subsection{Modifie}
L'algorithme ne modifie rien.
\subsection{Postcondition}
La première postcondition est, informellement, que si la valeur booléenne est vraie,
alors $i$ et $j$ contiennent les bonnes valeurs d'indices.
La seconde postcondition est que si la valeur booléenne est fausse,
alors la somme de toute paire est différente de $s$ et que si la somme est différente de $s$ pour toute paire, alors la valeur booléenne retournée est fausse.
Formellement (en appelant \inlinedafny{found} la valeur booléenne),
\begin{align*}
&\textnormal{\inlinedafny{found}} \implies (0 \le i \le j < \abs{a}) \land (a[i] + a[j] = s) \\
\land \lnot &\textnormal{\inlinedafny{found}} \iff \forall m, n \mid 0 \le m \le n < \abs{a} :: a[m] + a[n] \ne s\,.
\end{align*}

\section{Implémentation}
L'implémentation de l'algorithme donné précédemment en Dafny est la suivante.
\lstfile{../src/find_sum.dfy}

\section{Graphe d'exécution}
Le graphe d'exécution pour l'algorithme ci-dessus est donné sur la \textsc{Figure}~\ref{fig:execgraph}.
\begin{figure}[htbp]
	\centering
	\includesvg[width=\textwidth]{execgraph}
	\caption{Le graphe d'exécution complet pour le programme donné.}
	\label{fig:execgraph}
\end{figure}
Afin de faciliter les preuves, chaque chemin simple est redessiné à coté de sa preuve de correction.
\begin{figure}[htbp]
	\begin{subfigure}{0.3\textwidth}
	\centering
	\includesvg[width=0.5\textwidth]{simplepath4}
	\label{fig:4}
	\end{subfigure}\hfill
	\begin{subfigure}{0.3\textwidth}
	\centering
	\includesvg[width=0.5\textwidth]{simplepath5}
	\label{fig:5}
	\end{subfigure}
	\caption{Représentations plus propres des différents chemins simples.}
	\label{fig:simplepaths}
\end{figure}

\section{Preuve de correction}
Avant de prouver la correction des différents chemins simples, définissons quelques prédicats:
\begin{align*}
\textnormal{\inlinedafny{sorted}}(a) \equiv \forall k, \ell \mid 0 \le k \le \ell < \abs{a} :: a[k] \le a[\ell] \tag{Pre} \\\\
\begin{array}{l}
\phantom{{} \land {}} 0 \le i \le j+1 \le \abs{a} \\ {} \land \forall p, x \mid 0 \le p < i \land 0 \le x < \abs{a} :: a[p] + a[x] \ne s \\ {} \land \forall q, x \mid j < q < \abs{a} \land 0 \le x < \abs{a} :: a[x] + a[q] \ne s
\end{array}\tag{I}
\end{align*}
\subsection{Précondition jusqu'à l'entrée de la boucle}
\noindent\begin{minipage}[c]{0.5\textwidth}
\centering
\begin{figure}[H]
	\centering
	\includesvg[width=0.3\textwidth]{simplepath1}
	\caption*{@Pre $\to$ @I.}
	\label{fig:1}
\end{figure}
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}
\begin{align*}
&\Big[\textnormal{Pre} \Big] \\
&\Big[0 \le 0 \le \abs{a} - 1 +1 \le \abs{a} \\
&\land \forall p, x \mid 0 \le p < 0 \land 0 \le x < \abs{a} :: a[p] + a[x] \ne s \\
&\land \forall q, x \mid \abs{a} - 1 < q < \abs{a} \land 0 \le x < \abs{a} :: a[x] + a[q] \ne s\Big] \\
&\textnormal{\inlinedafny{i, j := 0, |a| - 1;}} \\
&\Big[\textnormal{I} \Big]
\end{align*}
Afin d'affirmer la correction de ce chemin simple, on doit encore prouver que le deuxième prédicat est bien une conséquence de la précondition.
\begin{proof}
On peut simplifier ce deuxième prédicat pour montrer qu'il est en fait équivalent à $\top$.
Il est donc toujours impliqué par la précondition.
\end{proof}
\end{minipage}
\subsection{Boucle dans le cas $m > s$}
\noindent\begin{minipage}[c]{0.5\textwidth}
\centering
\begin{figure}[H]
	\centering
	\includesvg[width=0.3\textwidth]{simplepath2}
	\caption*{@I $\to$ @I pour $m > s$.}
	\label{fig:2}
\end{figure}
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}
\begin{align*}
&\Big[\textnormal{I} \Big] \\
&\Big[i \le j \implies \big(a[i] + a[j] > s \implies \textnormal{I}_2\big) \Big] \\
&\textnormal{\inlinedafny{assume i <= j;}} \\
&\Big[a[i] + a[j] > s \implies \textnormal{I}_2 \Big] \\
&\textnormal{\inlinedafny{m := a[i] + a[j];}} \\
&\Big[m > s \implies \textnormal{I}_2 \Big] \\
&\textnormal{\inlinedafny{assume m > s;}} \\
&\Big[\textnormal{I}_2\Big] \equiv \Big[0 \le i \le j \le \abs{a} \\
&\land \forall p, x \mid 0 \le p < i \land 0 \le x < \abs{a} :: a[p] + a[x] \ne s \\
&\land \forall q, x \mid j-1 < q < \abs{a} \land 0 \le x < \abs{a} :: a[x] + a[q] \ne s \Big] \\
&\textnormal{\inlinedafny{j := j - 1;}} \\
&\Big[\textnormal{I} \Big]
\end{align*}
Pour montrer que l'invariant implique bien le deuxième prédicat,
on doit prouver que
\begin{align*}
&\Big(\textnormal{I} \implies \Big[i \le j \implies \big(a[i] + a[j] > s \implies \textnormal{I}_2\big) \Big]\Big) \\
\equiv &\Big[\textnormal{I} \land i \le j \land a[i] + a[j] > s\Big] \implies \textnormal{I}_2\,.
\end{align*}
\begin{proof}
Pour ne pas trop surcharger les équations, on procède partie par partie.
Dans l'invariant I, la première partie de la conjonction devient $0 \le i < j \le \abs{a}$,
car $(i \le j+1) \land (i \le j) \equiv i \le j$ et $j+1 \le \abs{a} \implies j \le \abs{a}$.
La deuxième partie de la conjonction est exactement la même dans I et I$_2$,
et ne nécessite donc pas de développement.
Pour la troisième partie, elle est identique sauf dans le cas $q = j$.
Dans ce cas, comme on a également que $a[i] + a[j] > s$,
et que le tableau est trié, le seul moyen d'obtenir $a[i] + a[j] = s$ avec $a[j]$ fixé serait de prendre un élément $a[p] < a[i]$, avec donc $0 \le p < i$, comme le tableau est trié.
Or, par la deuxième partie de la conjonction de l'invariant, on sait que $\forall p, x \mid 0 \le p < i \land 0 \le x < \abs{a} :: a[p] + a[x] \ne s$.
Dans notre cas de figure, il suffit de prendre $x = j$ pour prouver qu'on n'aura jamais $a[p] + a[j] = s$ pour $0 \le 0 p < i$.
\end{proof}
\end{minipage}

\subsection{Boucle dans le cas $m < s$}
\noindent\begin{minipage}[c]{0.5\textwidth}
\centering
\begin{figure}[H]
	\centering
	\includesvg[width=0.3\textwidth]{simplepath3}
	\caption*{@I $\to$ @I pour $m < s$.}
	\label{fig:3}
\end{figure}
\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}
\begin{align*}
&\Big[\textnormal{I} \Big] \\
&\Big[i \le j \implies \big(a[i] + a[j] < s \implies \textnormal{I}_3\big) \Big] \\
&\textnormal{\inlinedafny{assume i <= j;}} \\
&\Big[a[i] + a[j] < s \implies \textnormal{I}_3 \Big] \\
&\textnormal{\inlinedafny{m := a[i] + a[j];}} \\
&\Big[\big(\lnot(m > s) \implies (m < s \implies \textnormal{I}_3)\big) \equiv \big(m < s \implies \textnormal{I}_3\big)\Big] \\
&\textnormal{\inlinedafny{assume !(m > s);}} \\
&\Big[m < s \implies \textnormal{I}_3 \Big] \\
&\textnormal{\inlinedafny{assume m < s;}} \\
&\Big[\textnormal{I}_3\Big] \equiv \Big[0 \le i + 1 \le j + 1 \le \abs{a} \\
&\land \forall p, x \mid 0 \le p < i + 1 \land 0 \le x < \abs{a} :: a[p] + a[x] \ne s \\
&\land \forall q, x \mid j < q < \abs{a} \land 0 \le x < \abs{a} :: a[x] + a[q] \ne s \Big] \\
&\textnormal{\inlinedafny{i := i +1;}}\\
&\Big[\textnormal{I} \Big]
\end{align*}
Pour montrer que l'invariant implique bien le deuxième prédicat,
on doit prouver que
\begin{align*}
&\Big(\textnormal{I} \implies \Big[i \le j \implies \big(a[i] + a[j] < s \implies \textnormal{I}_3\big) \Big]\Big) \\
\equiv &\Big[\textnormal{I} \land i \le j \land a[i] + a[j] < s\Big] \implies \textnormal{I}_3\,.
\end{align*}
\begin{proof}
Pour ne pas trop surcharger les équations, on procède partie par partie.
Dans l'invariant I, la première partie de la conjonction devient $0 \le i < j \le \abs{a}$,
car $(i \le j+1) \land (i \le j) \equiv i \le j$ et $j+1 \le \abs{a} \implies j \le \abs{a}$.
La troisième partie de la conjonction est exactement la même dans I et I$_3$,
et ne nécessite donc pas de développement.
Pour la deuxième partie, elle est identique sauf dans le cas $p = i$.
Dans ce cas, comme on a également que $a[i] + a[j] < s$,
et que le tableau est trié, le seul moyen d'obtenir $a[i] + a[j] = s$ avec $a[i]$ fixé serait de prendre un élément $a[q] > a[j]$, avec donc $j  < p < \abs{a}$, comme le tableau est trié.
Or, par la troisième partie de la conjonction de l'invariant, on sait que $\forall q, x \mid j < p < \abs{a} \land 0 \le x < \abs{a} :: a[x] + a[q] \ne s$.
Dans notre cas de figure, il suffit de prendre $x = i$ pour prouver qu'on n'aura jamais $a[i] + a[q] = s$ pour $j < q < \abs{a}$.
\end{proof}
\end{minipage}


\begin{thebibliography}{00}
	\bibitem{robtex} \url{https://www.robtex.com/dns-lookup/www.aliexpress.com}, accessed on December 1, 2018.
\end{thebibliography}
\end{document}