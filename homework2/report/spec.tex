\documentclass{elsarticle}
\usepackage[a4paper,left=2.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm]{geometry}
\usepackage{natbib}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathtools}
\usepackage[french]{babel}
\usepackage{bm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{../../dafny}
\lstset{language=dafny}
\graphicspath{{img/}}
\usepackage{svg}

\makeatletter
\def\ps@pprintTitle{%
	\let\@oddhead\@empty
	\let\@evenhead\@empty
	\def\@oddfoot{\centerline{\thepage}}%
	\let\@evenfoot\@oddfoot}
\makeatother

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
		T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage{siunitx}

\newcommand{\abs}{\ensuremath{\textnormal{\inlinedafny|abs|}}}

\newcommand{\ok}{\ensuremath{\textnormal{\inlinedafny|ok|}}}

\DeclareMathOperator{\size}{size}
\DeclareMathOperator{\height}{height}
\DeclareMathOperator{\type}{type}

\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\theta}{\vartheta}
\renewcommand{\kappa}{\varkappa}
\renewcommand{\rho}{\varrho}
\renewcommand{\phi}{\varphi}

\begin{document}
\title{Méthodes de conception de programmes \\ Devoir 2: 1, 2, 3\ldots{} Arbres!}
\date{30 avril 2019}

\address[add1]{École Polytechnique, Université catholique de Louvain, Place de l'Université 1, 1348 Ottignies-Louvain-la-Neuve, Belgique}

\author[add1]{Alexandre \textsc{Gobeaux}}
\ead{alexandre.gobeaux@student.uclouvain.be}

\author[add1]{Louis \textsc{Navarre}}
\ead{navarre.louis@student.uclouvain.be}

\author[add1]{Gilles \textsc{Peiffer}}
\ead{gilles.peiffer@student.uclouvain.be}

\begin{abstract}
Ce papier donne les invariants de représentation, la fonction d'abstraction et les spécifications des fonctions \inlinedafny|insert| et \inlinedafny|join| pour une implémentation des arbres 2-3 basée sur \cite{algs4th} et \cite{wiki:23tree}.
\end{abstract}
\maketitle

\section{Invariant de représentation}
Commençons par définir quelques fonctions auxiliaires:
\begin{itemize}
	\item \(\size(T)\): donne le nombre de n\oe{}uds d'un arbre \(T\);
	\item \(\height(T)\): donne la hauteur d'un arbre \(T\);
	\item \(\type(T)\): donne le nombre de sours-arbres du n\oe{}ud source de l'arbre \(T\).
\end{itemize}
Afin d'alléger la notation de l'invariant de représentation \(\ok(T)\), voici quelques fonctions supplémentaires.
\begin{itemize}
	\item Si le n\oe{}ud source de \(T\) est un 2-n\oe{}ud, alors \(L\) et \(R\) dénotent respectivement le sous-arbre de gauche et de droite de \(T\), alors que \(a\) dénote la donnée de son n\oe{}ud source.
	\item Si le n\oe{}ud source de \(T\) est un 3-n\oe{}ud, alors \(L\), \(M\) et \(R\) dénotent respectivement le sous-arbre de gauche, du milieu et de droite de \(T\), alors que \(a< b\) sont les données du n\oe{}ud source.
\end{itemize}
\begin{align}
f(T) &= \Big(\size(L) > 0 \land \size(R) > 0\Big) \land \Big(\height(L) = \height(R)\Big) \land \Big(\forall \lambda \in L, \rho \in R : \lambda < a \le \rho \Big)\,,\\
g(T) &= \begin{multlined}[t] \Big(\size(L) > 0 \land \size(M) > 0 \land \size(R) > 0\Big) \land \Big(\height(L) = \height(M) = \height(R)\Big) \land {}\\ \Big(\forall \lambda \in L, \mu \in M, \rho \in R : \lambda < a \le \mu < b \le \rho \Big)\,.
\end{multlined}
\end{align}

L'invariant de représentation est alors donné par
\begin{equation}
\ok(T) \equiv \size(T) = 0 \lor \Big(\type(T) = 2 \land f(T)\Big) \lor  \Big(\type(T) = 3 \land g(T)\Big)\,.
\end{equation}

\section{Fonction d'abstraction}
La fonction d'abstraction \abs() est donnée par
\begin{equation}
\abs() = \,.
\end{equation}

\section{Spécifications formelles}
\subsection{Spécification de \inlinedafny|insert(t: Tree, i: int) returns (t': Tree)|}
\subsubsection{Précondition}
La précondition est simplement que l'invariant de représentation soit respecté.
\begin{dafny}
@Pre $\equiv$ ok(t)
\end{dafny}

\subsubsection{Postcondition}
Comme la fonction \inlinedafny|insert| doit conserver le rep-invariant, il fait également partie de la postcondition.
En plus de cela, on requiert également que le multiensemble des éléments du nouvel arbre soit égal au multiensemble résultant de l'union de l'arbre original et de \inlinedafny|i|, où les multiensemble sont définis comme dans~\cite{blizard1991}.
\begin{dafny}
@Post $\equiv$ ok(t') $\land$ elements(t') $=$ elements(t) $\cup$ multiset(i)
\end{dafny}
Ici, \inlinedafny|elements| est une fonction qui prend en argument un arbre 2-3 et retourne le multiensemble de ses éléments.

\subsection{Spécification de \inlinedafny|join(t1: Tree, t2: Tree) returns (t: Tree)|}
\subsubsection{Précondition}
La fonction \inlinedafny|join| a comme précondition que les deux arbres pris en argument soient des arbres 2-3 valables.
\begin{dafny}
@Pre $\equiv$ ok(t1) $\land$ ok(t2)
\end{dafny}

\subsubsection{Postcondition}
Le résultat de la fonction \inlinedafny|join| doit également être un arbre 2-3 valable.
En plus de cela, on requiert également que le multiensemble des éléments du nouvel arbre soit égal au multiensemble résultant de l'union des deux arbres initiaux.
\begin{dafny}
@Post $\equiv$ ok(t) $\land$ elements(t) $=$ elements(t1) $\cup$ elements(t2)
\end{dafny}
La fonction \inlinedafny|elements| est la même que pour \inlinedafny|insert|.

\section*{Références}

\bibliography{ref}
\bibliographystyle{elsarticle-harv}\biboptions{authoryear}

\end{document}
\endinput